/**
 * AI Assimilation MCP Server
 * Main server implementation using @modelcontextprotocol/sdk
 */

import { Server } from '@modelcontextprotocol/sdk/server/index.js';
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';
import {
  CallToolRequestSchema,
  ListToolsRequestSchema,
  Tool,
} from '@modelcontextprotocol/sdk/types.js';

import { MCPConfig } from '../config/index.js';
import { logger } from '../utils/logger.js';
import { ErrorHandler } from '../utils/errors.js';
import { MCPResponse } from '../types/index.js';
import { ExportManager } from './exportManager.js';

export class AIAssimilationMCPServer {
  private server: Server;
  private config: MCPConfig;
  private exportManager: ExportManager;

  constructor(config: MCPConfig) {
    this.config = config;
    this.exportManager = new ExportManager(config.storage.baseDirectory);
    
    this.server = new Server(
      {
        name: config.server.name,
        version: config.server.version,
      },
      {
        capabilities: {
          tools: {},
        },
      }
    );

    this.setupHandlers();
    logger.info('AI Assimilation MCP Server initialized', {
      name: config.server.name,
      version: config.server.version,
      baseDirectory: config.storage.baseDirectory
    });
  }

  private setupHandlers(): void {
    // List available tools
    this.server.setRequestHandler(ListToolsRequestSchema, async () => {
      return {
        tools: this.getAvailableTools(),
      };
    });

    // Handle tool calls
    this.server.setRequestHandler(CallToolRequestSchema, async (request) => {
      const { name, arguments: args } = request.params;
      
      try {
        logger.info('Tool called', { name, args });
        
        switch (name) {
          case 'export_experience_init':
            return await this.handleExportInit(args);
          case 'export_experience_conversations':
            return await this.handleExportConversations(args);
          case 'export_experience_insights':
            return await this.handleExportInsights(args);
          case 'export_experience_patterns':
            return await this.handleExportPatterns(args);
          case 'export_experience_preferences':
            return await this.handleExportPreferences(args);
          case 'export_experience_finalize':
            return await this.handleExportFinalize(args);
          case 'list_experiences':
            return await this.handleListExperiences(args);
          case 'validate_experience':
            return await this.handleValidateExperience(args);
          case 'get_assimilation_guide':
            return await this.handleGetAssimilationGuide(args);
          default:
            throw new Error(`Unknown tool: ${name}`);
        }
      } catch (error) {
        logger.error('Tool execution failed', { name, error: error instanceof Error ? error.message : String(error) });
        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify(ErrorHandler.toMCPResponse(error as Error), null, 2)
            }
          ]
        };
      }
    });
  }

  private getAvailableTools(): Tool[] {
    return [
      {
        name: 'export_experience_init',
        description: '体験データエクスポートの初期化とディレクトリ構造作成',
        inputSchema: {
          type: 'object',
          properties: {
            session_id: { type: 'string', description: 'セッション識別子' },
            output_directory: { type: 'string', description: '出力ディレクトリパス' },
            metadata: { type: 'object', description: 'セッションメタデータ' },
            summary: { type: 'object', description: '体験データの概要' }
          },
          required: ['session_id', 'output_directory', 'metadata', 'summary']
        }
      },
      {
        name: 'export_experience_conversations',
        description: '会話履歴データのバッチ単位での個別ファイル出力',
        inputSchema: {
          type: 'object',
          properties: {
            export_id: { type: 'string', description: 'エクスポート処理識別子' },
            conversations_batch: { type: 'array', description: '会話データのバッチ（50件ベース）' },
            batch_number: { type: 'number', description: 'バッチ番号' },
            is_final_batch: { type: 'boolean', description: '最終バッチかどうか' }
          },
          required: ['export_id', 'conversations_batch', 'batch_number']
        }
      },
      {
        name: 'export_experience_insights',
        description: '洞察データの個別ファイル出力',
        inputSchema: {
          type: 'object',
          properties: {
            export_id: { type: 'string', description: 'エクスポート処理識別子' },
            insights: { type: 'array', description: '洞察データ' }
          },
          required: ['export_id', 'insights']
        }
      },
      {
        name: 'export_experience_patterns',
        description: '推論パターンデータの個別ファイル出力',
        inputSchema: {
          type: 'object',
          properties: {
            export_id: { type: 'string', description: 'エクスポート処理識別子' },
            reasoning_patterns: { type: 'array', description: '推論パターンデータ' }
          },
          required: ['export_id', 'reasoning_patterns']
        }
      },
      {
        name: 'export_experience_preferences',
        description: '学習した嗜好データの個別ファイル出力',
        inputSchema: {
          type: 'object',
          properties: {
            export_id: { type: 'string', description: 'エクスポート処理識別子' },
            learned_preferences: { type: 'object', description: '学習した嗜好データ' }
          },
          required: ['export_id', 'learned_preferences']
        }
      },
      {
        name: 'export_experience_finalize',
        description: 'エクスポート処理の完了とマニフェストファイル生成',
        inputSchema: {
          type: 'object',
          properties: {
            export_id: { type: 'string', description: 'エクスポート処理識別子' }
          },
          required: ['export_id']
        }
      },
      {
        name: 'list_experiences',
        description: '利用可能な体験データディレクトリの一覧取得',
        inputSchema: {
          type: 'object',
          properties: {
            base_directory: { type: 'string', description: '検索ベースディレクトリ' },
            filter: { type: 'object', description: 'フィルタ条件' }
          }
        }
      },
      {
        name: 'validate_experience',
        description: '体験データディレクトリの整合性検証',
        inputSchema: {
          type: 'object',
          properties: {
            directory_path: { type: 'string', description: '検証する体験データディレクトリパス' }
          },
          required: ['directory_path']
        }
      },
      {
        name: 'get_assimilation_guide',
        description: 'AI同化プロセスのガイドラインとベストプラクティスを提供',
        inputSchema: {
          type: 'object',
          properties: {
            guide_type: { 
              type: 'string', 
              enum: ['for_main_ai', 'for_source_ai'],
              description: 'ガイドの種類'
            }
          },
          required: ['guide_type']
        }
      }
    ];
  }

  // Export tool implementations
  private async handleExportInit(args: any): Promise<any> {
    try {
      // Validate required parameters
      const { session_id, output_directory, metadata, summary } = args;
      
      if (!session_id || !output_directory || !metadata || !summary) {
        throw new Error('Missing required parameters: session_id, output_directory, metadata, summary');
      }

      // Validate summary structure
      const requiredSummaryFields = [
        'ai_name', 'ai_context', 'experience_nature', 
        'experience_summary', 'experience_flow', 'main_topics', 'estimated_conversations'
      ];
      
      for (const field of requiredSummaryFields) {
        if (!(field in summary)) {
          throw new Error(`Missing required summary field: ${field}`);
        }
      }

      // Initialize export
      const result = await this.exportManager.initializeExport({
        session_id,
        output_directory,
        metadata,
        summary
      });

      return {
        content: [
          {
            type: 'text',
            text: JSON.stringify(result, null, 2)
          }
        ]
      };

    } catch (error) {
      logger.error('Export initialization failed', { 
        error: error instanceof Error ? error.message : String(error),
        args 
      });
      
      return {
        content: [
          {
            type: 'text',
            text: JSON.stringify({
              success: false,
              export_id: '',
              directory_path: '',
              expected_files: {},
              error: error instanceof Error ? error.message : String(error)
            }, null, 2)
          }
        ]
      };
    }
  }

  private async handleExportConversations(args: any): Promise<any> {
    try {
      // Validate required parameters
      const { export_id, conversations_batch, batch_number, is_final_batch } = args;
      
      if (!export_id || !conversations_batch || batch_number === undefined) {
        throw new Error('Missing required parameters: export_id, conversations_batch, batch_number');
      }

      if (!Array.isArray(conversations_batch)) {
        throw new Error('conversations_batch must be an array');
      }

      if (typeof batch_number !== 'number' || batch_number < 1) {
        throw new Error('batch_number must be a positive integer');
      }

      // Export conversation batch
      const result = await this.exportManager.exportConversationBatch({
        export_id,
        conversations_batch,
        batch_number,
        is_final_batch: is_final_batch || false
      });

      return {
        content: [
          {
            type: 'text',
            text: JSON.stringify(result, null, 2)
          }
        ]
      };

    } catch (error) {
      logger.error('Conversation batch export failed', { 
        error: error instanceof Error ? error.message : String(error),
        args 
      });
      
      return {
        content: [
          {
            type: 'text',
            text: JSON.stringify({
              success: false,
              file_path: '',
              processed_count: 0,
              batch_file_size: 0,
              error: error instanceof Error ? error.message : String(error)
            }, null, 2)
          }
        ]
      };
    }
  }

  private async handleExportInsights(args: any): Promise<any> {
    try {
      // Validate required parameters
      const { export_id, insights } = args;
      
      if (!export_id || !insights) {
        throw new Error('Missing required parameters: export_id, insights');
      }

      if (!Array.isArray(insights)) {
        throw new Error('insights must be an array');
      }

      // Export insights
      const result = await this.exportManager.exportInsights({
        export_id,
        data: insights
      });

      return {
        content: [
          {
            type: 'text',
            text: JSON.stringify(result, null, 2)
          }
        ]
      };

    } catch (error) {
      logger.error('Insights export failed', { 
        error: error instanceof Error ? error.message : String(error),
        args 
      });
      
      return {
        content: [
          {
            type: 'text',
            text: JSON.stringify({
              success: false,
              file_path: '',
              items_count: 0,
              error: error instanceof Error ? error.message : String(error)
            }, null, 2)
          }
        ]
      };
    }
  }

  private async handleExportPatterns(args: any): Promise<any> {
    try {
      // Validate required parameters
      const { export_id, reasoning_patterns } = args;
      
      if (!export_id || !reasoning_patterns) {
        throw new Error('Missing required parameters: export_id, reasoning_patterns');
      }

      if (!Array.isArray(reasoning_patterns)) {
        throw new Error('reasoning_patterns must be an array');
      }

      // Export patterns
      const result = await this.exportManager.exportPatterns({
        export_id,
        data: reasoning_patterns
      });

      return {
        content: [
          {
            type: 'text',
            text: JSON.stringify(result, null, 2)
          }
        ]
      };

    } catch (error) {
      logger.error('Patterns export failed', { 
        error: error instanceof Error ? error.message : String(error),
        args 
      });
      
      return {
        content: [
          {
            type: 'text',
            text: JSON.stringify({
              success: false,
              file_path: '',
              items_count: 0,
              error: error instanceof Error ? error.message : String(error)
            }, null, 2)
          }
        ]
      };
    }
  }

  private async handleExportPreferences(args: any): Promise<any> {
    try {
      // Validate required parameters
      const { export_id, learned_preferences } = args;
      
      if (!export_id || !learned_preferences) {
        throw new Error('Missing required parameters: export_id, learned_preferences');
      }

      if (typeof learned_preferences !== 'object') {
        throw new Error('learned_preferences must be an object');
      }

      // Export preferences
      const result = await this.exportManager.exportPreferences({
        export_id,
        data: learned_preferences
      });

      return {
        content: [
          {
            type: 'text',
            text: JSON.stringify(result, null, 2)
          }
        ]
      };

    } catch (error) {
      logger.error('Preferences export failed', { 
        error: error instanceof Error ? error.message : String(error),
        args 
      });
      
      return {
        content: [
          {
            type: 'text',
            text: JSON.stringify({
              success: false,
              file_path: '',
              items_count: 0,
              error: error instanceof Error ? error.message : String(error)
            }, null, 2)
          }
        ]
      };
    }
  }

  private async handleExportFinalize(args: any): Promise<any> {
    try {
      // Validate required parameters
      const { export_id } = args;
      
      if (!export_id) {
        throw new Error('Missing required parameter: export_id');
      }

      // Finalize export
      const result = await this.exportManager.finalizeExport(export_id);

      return {
        content: [
          {
            type: 'text',
            text: JSON.stringify(result, null, 2)
          }
        ]
      };

    } catch (error) {
      logger.error('Export finalization failed', { 
        error: error instanceof Error ? error.message : String(error),
        args 
      });
      
      return {
        content: [
          {
            type: 'text',
            text: JSON.stringify({
              success: false,
              directory_path: '',
              manifest_path: '',
              total_files: 0,
              total_size: 0,
              file_list: [],
              error: error instanceof Error ? error.message : String(error)
            }, null, 2)
          }
        ]
      };
    }
  }

  private async handleListExperiences(args: any): Promise<any> {
    return {
      content: [
        {
          type: 'text',
          text: JSON.stringify({
            success: false,
            error: 'Not implemented yet - will be implemented in task 4.1'
          }, null, 2)
        }
      ]
    };
  }

  private async handleValidateExperience(args: any): Promise<any> {
    return {
      content: [
        {
          type: 'text',
          text: JSON.stringify({
            success: false,
            error: 'Not implemented yet - will be implemented in task 4.2'
          }, null, 2)
        }
      ]
    };
  }

  private async handleGetAssimilationGuide(args: any): Promise<any> {
    return {
      content: [
        {
          type: 'text',
          text: JSON.stringify({
            success: false,
            error: 'Not implemented yet - will be implemented in task 5.1'
          }, null, 2)
        }
      ]
    };
  }

  async start(): Promise<void> {
    const transport = new StdioServerTransport();
    await this.server.connect(transport);
    logger.info('AI Assimilation MCP Server started and connected');
  }

  async stop(): Promise<void> {
    await this.server.close();
    logger.info('AI Assimilation MCP Server stopped');
  }
}